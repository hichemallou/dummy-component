{"ast":null,"code":"import _classCallCheck from \"/home/helektrika/Documents/dummy-component/component/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/helektrika/Documents/dummy-component/component/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ByteBuffer } from \"./byte-buffer.js\";\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants.js\";\nexport var Builder = /*#__PURE__*/function () {\n  /**\n   * Create a FlatBufferBuilder.\n   */\n  function Builder(opt_initial_size) {\n    _classCallCheck(this, Builder);\n    /** Minimum alignment encountered so far. */\n    this.minalign = 1;\n    /** The vtable for the current table. */\n    this.vtable = null;\n    /** The amount of fields we're actually using. */\n    this.vtable_in_use = 0;\n    /** Whether we are currently serializing a table. */\n    this.isNested = false;\n    /** Starting offset of the current struct/table. */\n    this.object_start = 0;\n    /** List of offsets of all vtables. */\n    this.vtables = [];\n    /** For the current vector being built. */\n    this.vector_num_elems = 0;\n    /** False omits default values from the serialized data */\n    this.force_defaults = false;\n    this.string_maps = null;\n    this.text_encoder = new TextEncoder();\n    var initial_size;\n    if (!opt_initial_size) {\n      initial_size = 1024;\n    } else {\n      initial_size = opt_initial_size;\n    }\n    /**\n     * @type {ByteBuffer}\n     * @private\n     */\n    this.bb = ByteBuffer.allocate(initial_size);\n    this.space = initial_size;\n  }\n  _createClass(Builder, [{\n    key: \"clear\",\n    value: function clear() {\n      this.bb.clear();\n      this.space = this.bb.capacity();\n      this.minalign = 1;\n      this.vtable = null;\n      this.vtable_in_use = 0;\n      this.isNested = false;\n      this.object_start = 0;\n      this.vtables = [];\n      this.vector_num_elems = 0;\n      this.force_defaults = false;\n      this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n  }, {\n    key: \"forceDefaults\",\n    value: function forceDefaults(_forceDefaults) {\n      this.force_defaults = _forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n  }, {\n    key: \"dataBuffer\",\n    value: function dataBuffer() {\n      return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n  }, {\n    key: \"asUint8Array\",\n    value: function asUint8Array() {\n      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n  }, {\n    key: \"prep\",\n    value: function prep(size, additional_bytes) {\n      // Track the biggest thing we've ever aligned to.\n      if (size > this.minalign) {\n        this.minalign = size;\n      }\n      // Find the amount of alignment needed such that `size` is properly\n      // aligned after `additional_bytes`\n      var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;\n      // Reallocate the buffer if needed.\n      while (this.space < align_size + size + additional_bytes) {\n        var old_buf_size = this.bb.capacity();\n        this.bb = Builder.growByteBuffer(this.bb);\n        this.space += this.bb.capacity() - old_buf_size;\n      }\n      this.pad(align_size);\n    }\n  }, {\n    key: \"pad\",\n    value: function pad(byte_size) {\n      for (var i = 0; i < byte_size; i++) {\n        this.bb.writeInt8(--this.space, 0);\n      }\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      this.bb.writeInt8(this.space -= 1, value);\n    }\n  }, {\n    key: \"writeInt16\",\n    value: function writeInt16(value) {\n      this.bb.writeInt16(this.space -= 2, value);\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(value) {\n      this.bb.writeInt32(this.space -= 4, value);\n    }\n  }, {\n    key: \"writeInt64\",\n    value: function writeInt64(value) {\n      this.bb.writeInt64(this.space -= 8, value);\n    }\n  }, {\n    key: \"writeFloat32\",\n    value: function writeFloat32(value) {\n      this.bb.writeFloat32(this.space -= 4, value);\n    }\n  }, {\n    key: \"writeFloat64\",\n    value: function writeFloat64(value) {\n      this.bb.writeFloat64(this.space -= 8, value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n  }, {\n    key: \"addInt8\",\n    value: function addInt8(value) {\n      this.prep(1, 0);\n      this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n  }, {\n    key: \"addInt16\",\n    value: function addInt16(value) {\n      this.prep(2, 0);\n      this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n  }, {\n    key: \"addInt32\",\n    value: function addInt32(value) {\n      this.prep(4, 0);\n      this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n  }, {\n    key: \"addInt64\",\n    value: function addInt64(value) {\n      this.prep(8, 0);\n      this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n  }, {\n    key: \"addFloat32\",\n    value: function addFloat32(value) {\n      this.prep(4, 0);\n      this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n  }, {\n    key: \"addFloat64\",\n    value: function addFloat64(value) {\n      this.prep(8, 0);\n      this.writeFloat64(value);\n    }\n  }, {\n    key: \"addFieldInt8\",\n    value: function addFieldInt8(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addInt8(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldInt16\",\n    value: function addFieldInt16(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addInt16(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldInt32\",\n    value: function addFieldInt32(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addInt32(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldInt64\",\n    value: function addFieldInt64(voffset, value, defaultValue) {\n      if (this.force_defaults || value !== defaultValue) {\n        this.addInt64(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldFloat32\",\n    value: function addFieldFloat32(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addFloat32(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldFloat64\",\n    value: function addFieldFloat64(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addFloat64(value);\n        this.slot(voffset);\n      }\n    }\n  }, {\n    key: \"addFieldOffset\",\n    value: function addFieldOffset(voffset, value, defaultValue) {\n      if (this.force_defaults || value != defaultValue) {\n        this.addOffset(value);\n        this.slot(voffset);\n      }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n  }, {\n    key: \"addFieldStruct\",\n    value: function addFieldStruct(voffset, value, defaultValue) {\n      if (value != defaultValue) {\n        this.nested(value);\n        this.slot(voffset);\n      }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n  }, {\n    key: \"nested\",\n    value: function nested(obj) {\n      if (obj != this.offset()) {\n        throw new Error('FlatBuffers: struct must be serialized inline.');\n      }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n  }, {\n    key: \"notNested\",\n    value: function notNested() {\n      if (this.isNested) {\n        throw new Error('FlatBuffers: object serialization must not be nested.');\n      }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n  }, {\n    key: \"slot\",\n    value: function slot(voffset) {\n      if (this.vtable !== null) this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n  }, {\n    key: \"offset\",\n    value: function offset() {\n      return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n  }, {\n    key: \"addOffset\",\n    value:\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    function addOffset(offset) {\n      this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n      this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n  }, {\n    key: \"startObject\",\n    value: function startObject(numfields) {\n      this.notNested();\n      if (this.vtable == null) {\n        this.vtable = [];\n      }\n      this.vtable_in_use = numfields;\n      for (var i = 0; i < numfields; i++) {\n        this.vtable[i] = 0; // This will push additional elements as needed\n      }\n\n      this.isNested = true;\n      this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n  }, {\n    key: \"endObject\",\n    value: function endObject() {\n      if (this.vtable == null || !this.isNested) {\n        throw new Error('FlatBuffers: endObject called without startObject');\n      }\n      this.addInt32(0);\n      var vtableloc = this.offset();\n      // Trim trailing zeroes.\n      var i = this.vtable_in_use - 1;\n      // eslint-disable-next-line no-empty\n      for (; i >= 0 && this.vtable[i] == 0; i--) {}\n      var trimmed_size = i + 1;\n      // Write out the current vtable.\n      for (; i >= 0; i--) {\n        // Offset relative to the start of the table.\n        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n      }\n      var standard_fields = 2; // The fields below:\n      this.addInt16(vtableloc - this.object_start);\n      var len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n      this.addInt16(len);\n      // Search for an existing vtable that matches the current one.\n      var existing_vtable = 0;\n      var vt1 = this.space;\n      outer_loop: for (i = 0; i < this.vtables.length; i++) {\n        var vt2 = this.bb.capacity() - this.vtables[i];\n        if (len == this.bb.readInt16(vt2)) {\n          for (var j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existing_vtable = this.vtables[i];\n          break;\n        }\n      }\n      if (existing_vtable) {\n        // Found a match:\n        // Remove the current vtable.\n        this.space = this.bb.capacity() - vtableloc;\n        // Point table to existing vtable.\n        this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n      } else {\n        // No match:\n        // Add the location of the current vtable to the list of vtables.\n        this.vtables.push(this.offset());\n        // Point table to current vtable.\n        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n      }\n      this.isNested = false;\n      return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish(root_table, opt_file_identifier, opt_size_prefix) {\n      var size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n      if (opt_file_identifier) {\n        var file_identifier = opt_file_identifier;\n        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);\n        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n          throw new Error('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n        }\n        for (var i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n          this.writeInt8(file_identifier.charCodeAt(i));\n        }\n      }\n      this.prep(this.minalign, SIZEOF_INT + size_prefix);\n      this.addOffset(root_table);\n      if (size_prefix) {\n        this.addInt32(this.bb.capacity() - this.space);\n      }\n      this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n  }, {\n    key: \"finishSizePrefixed\",\n    value: function finishSizePrefixed(root_table, opt_file_identifier) {\n      this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n  }, {\n    key: \"requiredField\",\n    value: function requiredField(table, field) {\n      var table_start = this.bb.capacity() - table;\n      var vtable_start = table_start - this.bb.readInt32(table_start);\n      var ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;\n      // If this fails, the caller will show what field needs to be set.\n      if (!ok) {\n        throw new Error('FlatBuffers: field ' + field + ' must be set');\n      }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n  }, {\n    key: \"startVector\",\n    value: function startVector(elem_size, num_elems, alignment) {\n      this.notNested();\n      this.vector_num_elems = num_elems;\n      this.prep(SIZEOF_INT, elem_size * num_elems);\n      this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n  }, {\n    key: \"endVector\",\n    value: function endVector() {\n      this.writeInt32(this.vector_num_elems);\n      return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n  }, {\n    key: \"createSharedString\",\n    value: function createSharedString(s) {\n      if (!s) {\n        return 0;\n      }\n      if (!this.string_maps) {\n        this.string_maps = new Map();\n      }\n      if (this.string_maps.has(s)) {\n        return this.string_maps.get(s);\n      }\n      var offset = this.createString(s);\n      this.string_maps.set(s, offset);\n      return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n  }, {\n    key: \"createString\",\n    value: function createString(s) {\n      if (s === null || s === undefined) {\n        return 0;\n      }\n      var utf8;\n      if (s instanceof Uint8Array) {\n        utf8 = s;\n      } else {\n        utf8 = this.text_encoder.encode(s);\n      }\n      this.addInt8(0);\n      this.startVector(1, utf8.length, 1);\n      this.bb.setPosition(this.space -= utf8.length);\n      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n        bytes[offset++] = utf8[i];\n      }\n      return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n  }, {\n    key: \"createObjectOffset\",\n    value: function createObjectOffset(obj) {\n      if (obj === null) {\n        return 0;\n      }\n      if (typeof obj === 'string') {\n        return this.createString(obj);\n      } else {\n        return obj.pack(this);\n      }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n  }, {\n    key: \"createObjectOffsetList\",\n    value: function createObjectOffsetList(list) {\n      var ret = [];\n      for (var i = 0; i < list.length; ++i) {\n        var val = list[i];\n        if (val !== null) {\n          ret.push(this.createObjectOffset(val));\n        } else {\n          throw new Error('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n        }\n      }\n      return ret;\n    }\n  }, {\n    key: \"createStructOffsetList\",\n    value: function createStructOffsetList(list, startFunc) {\n      startFunc(this, list.length);\n      this.createObjectOffsetList(list.slice().reverse());\n      return this.endVector();\n    }\n  }], [{\n    key: \"growByteBuffer\",\n    value: function growByteBuffer(bb) {\n      var old_buf_size = bb.capacity();\n      // Ensure we don't grow beyond what fits in an int.\n      if (old_buf_size & 0xC0000000) {\n        throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n      }\n      var new_buf_size = old_buf_size << 1;\n      var nbb = ByteBuffer.allocate(new_buf_size);\n      nbb.setPosition(new_buf_size - old_buf_size);\n      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n      return nbb;\n    }\n  }]);\n  return Builder;\n}();","map":{"version":3,"names":["ByteBuffer","SIZEOF_SHORT","SIZE_PREFIX_LENGTH","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","Builder","opt_initial_size","_classCallCheck","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","string_maps","text_encoder","TextEncoder","initial_size","bb","allocate","space","_createClass","key","value","clear","capacity","forceDefaults","dataBuffer","asUint8Array","bytes","subarray","position","offset","prep","size","additional_bytes","align_size","old_buf_size","growByteBuffer","pad","byte_size","i","writeInt8","writeInt16","writeInt32","writeInt64","writeFloat32","writeFloat64","addInt8","addInt16","addInt32","addInt64","addFloat32","addFloat64","addFieldInt8","voffset","defaultValue","slot","addFieldInt16","addFieldInt32","addFieldInt64","addFieldFloat32","addFieldFloat64","addFieldOffset","addOffset","addFieldStruct","nested","obj","Error","notNested","startObject","numfields","endObject","vtableloc","trimmed_size","standard_fields","len","existing_vtable","vt1","outer_loop","length","vt2","readInt16","j","push","finish","root_table","opt_file_identifier","opt_size_prefix","size_prefix","file_identifier","charCodeAt","setPosition","finishSizePrefixed","requiredField","table","field","table_start","vtable_start","readInt32","ok","startVector","elem_size","num_elems","alignment","endVector","createSharedString","s","Map","has","get","createString","set","undefined","utf8","Uint8Array","encode","createObjectOffset","pack","createObjectOffsetList","list","ret","val","createStructOffsetList","startFunc","slice","reverse","new_buf_size","nbb"],"sources":["/home/helektrika/Documents/dummy-component/component/frontend/node_modules/flatbuffers/mjs/builder.js"],"sourcesContent":["import { ByteBuffer } from \"./byte-buffer.js\";\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants.js\";\nexport class Builder {\n    /**\n     * Create a FlatBufferBuilder.\n     */\n    constructor(opt_initial_size) {\n        /** Minimum alignment encountered so far. */\n        this.minalign = 1;\n        /** The vtable for the current table. */\n        this.vtable = null;\n        /** The amount of fields we're actually using. */\n        this.vtable_in_use = 0;\n        /** Whether we are currently serializing a table. */\n        this.isNested = false;\n        /** Starting offset of the current struct/table. */\n        this.object_start = 0;\n        /** List of offsets of all vtables. */\n        this.vtables = [];\n        /** For the current vector being built. */\n        this.vector_num_elems = 0;\n        /** False omits default values from the serialized data */\n        this.force_defaults = false;\n        this.string_maps = null;\n        this.text_encoder = new TextEncoder();\n        let initial_size;\n        if (!opt_initial_size) {\n            initial_size = 1024;\n        }\n        else {\n            initial_size = opt_initial_size;\n        }\n        /**\n         * @type {ByteBuffer}\n         * @private\n         */\n        this.bb = ByteBuffer.allocate(initial_size);\n        this.space = initial_size;\n    }\n    clear() {\n        this.bb.clear();\n        this.space = this.bb.capacity();\n        this.minalign = 1;\n        this.vtable = null;\n        this.vtable_in_use = 0;\n        this.isNested = false;\n        this.object_start = 0;\n        this.vtables = [];\n        this.vector_num_elems = 0;\n        this.force_defaults = false;\n        this.string_maps = null;\n    }\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults) {\n        this.force_defaults = forceDefaults;\n    }\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     */\n    dataBuffer() {\n        return this.bb;\n    }\n    /**\n     * Get the bytes representing the FlatBuffer. Only call this after you've\n     * called finish().\n     */\n    asUint8Array() {\n        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n    }\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param size This is the of the new element to write\n     * @param additional_bytes The padding size\n     */\n    prep(size, additional_bytes) {\n        // Track the biggest thing we've ever aligned to.\n        if (size > this.minalign) {\n            this.minalign = size;\n        }\n        // Find the amount of alignment needed such that `size` is properly\n        // aligned after `additional_bytes`\n        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n        // Reallocate the buffer if needed.\n        while (this.space < align_size + size + additional_bytes) {\n            const old_buf_size = this.bb.capacity();\n            this.bb = Builder.growByteBuffer(this.bb);\n            this.space += this.bb.capacity() - old_buf_size;\n        }\n        this.pad(align_size);\n    }\n    pad(byte_size) {\n        for (let i = 0; i < byte_size; i++) {\n            this.bb.writeInt8(--this.space, 0);\n        }\n    }\n    writeInt8(value) {\n        this.bb.writeInt8(this.space -= 1, value);\n    }\n    writeInt16(value) {\n        this.bb.writeInt16(this.space -= 2, value);\n    }\n    writeInt32(value) {\n        this.bb.writeInt32(this.space -= 4, value);\n    }\n    writeInt64(value) {\n        this.bb.writeInt64(this.space -= 8, value);\n    }\n    writeFloat32(value) {\n        this.bb.writeFloat32(this.space -= 4, value);\n    }\n    writeFloat64(value) {\n        this.bb.writeFloat64(this.space -= 8, value);\n    }\n    /**\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int8` to add the buffer.\n     */\n    addInt8(value) {\n        this.prep(1, 0);\n        this.writeInt8(value);\n    }\n    /**\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int16` to add the buffer.\n     */\n    addInt16(value) {\n        this.prep(2, 0);\n        this.writeInt16(value);\n    }\n    /**\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int32` to add the buffer.\n     */\n    addInt32(value) {\n        this.prep(4, 0);\n        this.writeInt32(value);\n    }\n    /**\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `int64` to add the buffer.\n     */\n    addInt64(value) {\n        this.prep(8, 0);\n        this.writeInt64(value);\n    }\n    /**\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float32` to add the buffer.\n     */\n    addFloat32(value) {\n        this.prep(4, 0);\n        this.writeFloat32(value);\n    }\n    /**\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n     * @param value The `float64` to add the buffer.\n     */\n    addFloat64(value) {\n        this.prep(8, 0);\n        this.writeFloat64(value);\n    }\n    addFieldInt8(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt8(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt16(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt16(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addInt32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldInt64(voffset, value, defaultValue) {\n        if (this.force_defaults || value !== defaultValue) {\n            this.addInt64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat32(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat32(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldFloat64(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addFloat64(value);\n            this.slot(voffset);\n        }\n    }\n    addFieldOffset(voffset, value, defaultValue) {\n        if (this.force_defaults || value != defaultValue) {\n            this.addOffset(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     */\n    addFieldStruct(voffset, value, defaultValue) {\n        if (value != defaultValue) {\n            this.nested(value);\n            this.slot(voffset);\n        }\n    }\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     */\n    nested(obj) {\n        if (obj != this.offset()) {\n            throw new Error('FlatBuffers: struct must be serialized inline.');\n        }\n    }\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested() {\n        if (this.isNested) {\n            throw new Error('FlatBuffers: object serialization must not be nested.');\n        }\n    }\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     */\n    slot(voffset) {\n        if (this.vtable !== null)\n            this.vtable[voffset] = this.offset();\n    }\n    /**\n     * @returns Offset relative to the end of the buffer.\n     */\n    offset() {\n        return this.bb.capacity() - this.space;\n    }\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param bb The current buffer with the existing data\n     * @returns A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     *\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n     * it a uint8Array we need to suppress the type check:\n     * @suppress {checkTypes}\n     */\n    static growByteBuffer(bb) {\n        const old_buf_size = bb.capacity();\n        // Ensure we don't grow beyond what fits in an int.\n        if (old_buf_size & 0xC0000000) {\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n        }\n        const new_buf_size = old_buf_size << 1;\n        const nbb = ByteBuffer.allocate(new_buf_size);\n        nbb.setPosition(new_buf_size - old_buf_size);\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n        return nbb;\n    }\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param offset The offset to add.\n     */\n    addOffset(offset) {\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\n    }\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     */\n    startObject(numfields) {\n        this.notNested();\n        if (this.vtable == null) {\n            this.vtable = [];\n        }\n        this.vtable_in_use = numfields;\n        for (let i = 0; i < numfields; i++) {\n            this.vtable[i] = 0; // This will push additional elements as needed\n        }\n        this.isNested = true;\n        this.object_start = this.offset();\n    }\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns The offset to the object inside `dataBuffer`\n     */\n    endObject() {\n        if (this.vtable == null || !this.isNested) {\n            throw new Error('FlatBuffers: endObject called without startObject');\n        }\n        this.addInt32(0);\n        const vtableloc = this.offset();\n        // Trim trailing zeroes.\n        let i = this.vtable_in_use - 1;\n        // eslint-disable-next-line no-empty\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\n        const trimmed_size = i + 1;\n        // Write out the current vtable.\n        for (; i >= 0; i--) {\n            // Offset relative to the start of the table.\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n        }\n        const standard_fields = 2; // The fields below:\n        this.addInt16(vtableloc - this.object_start);\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\n        this.addInt16(len);\n        // Search for an existing vtable that matches the current one.\n        let existing_vtable = 0;\n        const vt1 = this.space;\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\n            const vt2 = this.bb.capacity() - this.vtables[i];\n            if (len == this.bb.readInt16(vt2)) {\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n                        continue outer_loop;\n                    }\n                }\n                existing_vtable = this.vtables[i];\n                break;\n            }\n        }\n        if (existing_vtable) {\n            // Found a match:\n            // Remove the current vtable.\n            this.space = this.bb.capacity() - vtableloc;\n            // Point table to existing vtable.\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n        }\n        else {\n            // No match:\n            // Add the location of the current vtable to the list of vtables.\n            this.vtables.push(this.offset());\n            // Point table to current vtable.\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n        }\n        this.isNested = false;\n        return vtableloc;\n    }\n    /**\n     * Finalize a buffer, poiting to the given `root_table`.\n     */\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\n        if (opt_file_identifier) {\n            const file_identifier = opt_file_identifier;\n            this.prep(this.minalign, SIZEOF_INT +\n                FILE_IDENTIFIER_LENGTH + size_prefix);\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\n                throw new Error('FlatBuffers: file identifier must be length ' +\n                    FILE_IDENTIFIER_LENGTH);\n            }\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n                this.writeInt8(file_identifier.charCodeAt(i));\n            }\n        }\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\n        this.addOffset(root_table);\n        if (size_prefix) {\n            this.addInt32(this.bb.capacity() - this.space);\n        }\n        this.bb.setPosition(this.space);\n    }\n    /**\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\n     */\n    finishSizePrefixed(root_table, opt_file_identifier) {\n        this.finish(root_table, opt_file_identifier, true);\n    }\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     */\n    requiredField(table, field) {\n        const table_start = this.bb.capacity() - table;\n        const vtable_start = table_start - this.bb.readInt32(table_start);\n        const ok = field < this.bb.readInt16(vtable_start) &&\n            this.bb.readInt16(vtable_start + field) != 0;\n        // If this fails, the caller will show what field needs to be set.\n        if (!ok) {\n            throw new Error('FlatBuffers: field ' + field + ' must be set');\n        }\n    }\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param elem_size The size of each element in the array\n     * @param num_elems The number of elements in the array\n     * @param alignment The alignment of the array\n     */\n    startVector(elem_size, num_elems, alignment) {\n        this.notNested();\n        this.vector_num_elems = num_elems;\n        this.prep(SIZEOF_INT, elem_size * num_elems);\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n    }\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns The offset at which the newly created array\n     * starts.\n     */\n    endVector() {\n        this.writeInt32(this.vector_num_elems);\n        return this.offset();\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\n     * already been seen, we return the offset of the already written string\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createSharedString(s) {\n        if (!s) {\n            return 0;\n        }\n        if (!this.string_maps) {\n            this.string_maps = new Map();\n        }\n        if (this.string_maps.has(s)) {\n            return this.string_maps.get(s);\n        }\n        const offset = this.createString(s);\n        this.string_maps.set(s, offset);\n        return offset;\n    }\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param s The string to encode\n     * @return The offset in the buffer where the encoded string starts\n     */\n    createString(s) {\n        if (s === null || s === undefined) {\n            return 0;\n        }\n        let utf8;\n        if (s instanceof Uint8Array) {\n            utf8 = s;\n        }\n        else {\n            utf8 = this.text_encoder.encode(s);\n        }\n        this.addInt8(0);\n        this.startVector(1, utf8.length, 1);\n        this.bb.setPosition(this.space -= utf8.length);\n        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n            bytes[offset++] = utf8[i];\n        }\n        return this.endVector();\n    }\n    /**\n     * A helper function to pack an object\n     *\n     * @returns offset of obj\n     */\n    createObjectOffset(obj) {\n        if (obj === null) {\n            return 0;\n        }\n        if (typeof obj === 'string') {\n            return this.createString(obj);\n        }\n        else {\n            return obj.pack(this);\n        }\n    }\n    /**\n     * A helper function to pack a list of object\n     *\n     * @returns list of offsets of each non null object\n     */\n    createObjectOffsetList(list) {\n        const ret = [];\n        for (let i = 0; i < list.length; ++i) {\n            const val = list[i];\n            if (val !== null) {\n                ret.push(this.createObjectOffset(val));\n            }\n            else {\n                throw new Error('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\n            }\n        }\n        return ret;\n    }\n    createStructOffsetList(list, startFunc) {\n        startFunc(this, list.length);\n        this.createObjectOffsetList(list.slice().reverse());\n        return this.endVector();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}